archetype room

asset player identified by id {
    id : address;
    score: nat = 0;
    entry_block: nat;
}
asset leaderboard {
    idh : address;
    scoreh: nat;
}
constant oracle : key = "edpku2jGfeBS8X8axF5nSsduvwdA8Qq9mVhWjp3uTcQ4EMhbowsL7H"
constant orb_address : address = @KT1VSEeZZ5SiKeUGmEf7Drh4tRinNzEUBEJg
constant oracle_address: address = @KT1UqT4koMtfPZGSvqALfkvw3bNdCbyfXzZf
constant admin : address = @tz1W8RgHPiTDPqB5bGommn4QgJwMFuT3B1QF
constant treasury : address = @KT1UqT4koMtfPZGSvqALfkvw3bNdCbyfXzZf

constant room_size : nat = 10
constant bet_price : tez = 1tz
constant game_duration : nat = 30

variable v : list <address * nat > = []
variable n : nat = 0

enum betType = 
| Tez
| Orb
| OrbLP
| OtherLP

asset room {
    cid : string;
    finish_block  : nat = 0;
    players: aggregate<player> = [];
    bet_amount : tez;
    bet_type : betType = Tez;
    size: nat;
    distance: nat;
}

states = 
| Created initial
| InProgress
| Done
| Closed
| Refunded

entry create_room (room_id : string, bet_size : tez, size_v: nat, game_duration_v: nat) {
    called by admin
    effect {
        room.add({cid =room_id; bet_amount = bet_size; bet_type = Tez; size = size_v; distance = game_duration_v})
    }
}
entry enter_room (room_id : string) {
    // specification {
    //     s1 : true;
    // }
    called by any
    require {
        r1: transferred = room[room_id].bet_amount otherwise "Incorrect bet amount!";
        r3: player.count() < room_size otherwise "Room is full!" ;
    }
    effect {
        player.add({ id = caller; entry_block = level});
        room.update(room_id, {players += [caller]});
        // room[room_id].players.add(caller);
        if room[room_id].players.count() = 10 then room[room_id].finish_block := level + game_duration
    }
}

entry refund (room_id : string) {
    called by any
    require {
        r4: room[room_id].players.contains(caller) otherwise "Nothing to refund!";
        r5: room[room_id].players.count() < 10 otherwise "Game already started! Play or die!";
    }
    effect {
        player.remove(caller);
        room[room_id].players.remove(caller);
        if (not room[room_id].players.contains(caller)) then transfer bet_price to caller;
    }

}

entry endGame (room_id : string, packed_outcome : bytes, signed_outcome : signature) {
    require {
        // r6: level > room[room_id].finish_block otherwise "Game not ended!";
        // r7: room[room_id].players.contains(caller) otherwise "Are you participated?";
    }
    effect {
        var e = require_entrypoint<bytes * signature>("%setoutcome", oracle_address, "invalid address");
        transfer 0tz to entry e((packed_outcome, signed_outcome));
        match callview<list<address * nat>>(oracle_address, "getList", Unit) with
            | some(res) -> 
              v := res;
              n := length(res);
              for item in res do
                leaderboard.add({idh = item[0]; scoreh = item[1]})
              done
            | none -> fail("FAILED_TO_CALL_VIEW")
        end;        

      
    //   var bank = room_size * bet_price;
    //   var amount = 20% * bank;
    //   transfer  1tz to treasury; 
    //   transfer 1tz to v.nth(0)[0];
    //   transfer 1tz to v.nth(1)[0];
    //   transfer 1tz to v.nth(2)[0];

    }
}
